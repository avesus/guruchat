#pragma once

// Enumerate audio inputs
// List of current audio inputs.
// Fallback, позволяющий автоматически переключиться на другой аудиовход, если текущий становится недоступен (при отключении устройства).
// Чтобы такой fallback работал, необходима виртуализация групп источников.
// Имеет смысл, когда записывается только один канал.
// При многоканальной записи обрабатывается обычное отключение.

// Понятие перечисления не прикольно. Прикольнее список текущих входов.
// Управление всей этой периферией и каналами будет весьма затратным занятием.
// Если что-то отключается, движок захвата должен получить соотв. сообщение.
// Если появляется новое устройство, движок также должен об этом узнать.

// Устройства могут быть новые и старые. Для старых это просто "возвращение в строй",
// а новые должны присылать именно событие "новое".

// Если настроек сопоставления устройств группам захвата нет, движок получает события
// "новые устройства" аналогичным перечислению способом.

// Таким образом, движок в рантайме имеет список текущих устройств и сопоставленных
// им настроек. При повторном запуске программы этот список загружается
// из настроек и генерит сообщение "наше устройство теперь доступно".

// Дифференциация недоступного, удаленного и отключенного устройств не делается,
// для простоты.

// Итог:
// NEW, LOADED, UNLOADED

// При отображении списка устройств отображалка ПОДПИСЫВАЕТСЯ на данные уведомления.
// Чтобы отображалка получила каждый элемент, она должна получить 2 элемента:
// 1. Контейнер. Он будет слать только уведомление NEW.
// 2. Элементы в этом контейнере. Объекты. Доступны после того, как клиент подписался
// на уведомления NEW контейнера. Интерфейс отображения может сохранять отдельно
// свои специальные настройки, ассоциированные с элементами контейнера.
// Желательно, чтобы интерфейс мог сопоставлять их и ассоциировать при получении событий LOADED/UNLOADED.
// Возможность одновременной записи из нескольких источников.

// Enumerate audio outputs

// Источник должен запоминать, какие элементы были переданы наблюдателю.
// Если какие-то элементы появились, а потом исчезли, пока наблюдатель не был
// подписан, должна быть политика, позволяющая использовать
// оба режима (последнее состояние или цепочку состояний).
// Вопрос в том, зачем оно нужно. Так как мы строим абстракцию актуальных
// списков, то состояние будет доступно в обход, по другим интерфейсам.
// И история изменений состояния будет трекаться также по другим интерфейсам,
// только там, где оно действительно нужно.
// Итого: при подключении наблюдателя он должен получить текущий список элементов.
// Если наблюдатель раньше уже подключался, он должен на известные ему элементы
// получить уведомления "LOADED", на неизвестные - "NEW".
// Все элементы, которые переданы, в любой момент могут получить сообщение "UNLOADED".

// Datastream
// DatastreamAudio
// DatastreamVideo
// DatastreamIn
// DatastreamOut

// AudioSrc
// AudioDst
// VideoSrc
// VideoDst

// VideoSrcPool

// VideoCaptureSources - список видеокамер, в том числе и отключенных
// VideoPlaybackDestinations - список дисплеев, в том числе и отключенных
// AudioCaptureSources - список устройств захвата звука, в том числе отсутствующих
// AudioPlaybackDestinations - список устройств

class IDevice;
class IDeviceInfo;
class IDeviceSupply;

enum EOnOffBehavior
{
  ONOFFBEHAVIOR_IGNORE,
  ONOFFBEHAVIOR_PUSH_POP,
  ONOFFBEHAVIOR_ON_OFF
};

class IDeviceConsumer
{
public:
  // Called for backward connection with device supplier.
  // Device could be turned off and available. Called when app starts.
  virtual void onDeviceConnected(IDeviceSupply* supplier) = 0;

  // Called back when enumDevices() called.
  virtual void onDeviceListed(const IDeviceInfo* device) = 0;

  // IDevice ownself doesn't became the device, so IDeviceInfo supplied.
  virtual EOnOffBehavior onNewDevice(const IDeviceInfo* device) = 0;

  // Interesting because of possible format change.
  // Called back when 'STACK' returned from onNewDevice
  virtual void onDeviceChanged(IDeviceSupply* currentDevice) = 0;
  // Called back when threre is no any device then connected a device
  // or 'ONOFF' returned from onNewDevice
  virtual void onDeviceEnabled(IDeviceSupply* enabledDevice) = 0;
  // Called back when no active devices left or 'ONOFF' returned from onNewDevice
  virtual void onDeviceDisabled(IDeviceSupply* disabledDevice) = 0;
};

class IDeviceInfo
{
public:
  virtual const wchar_t* name() const = 0;
  virtual bool isEnabled() const = 0;
};

class IDeviceSupply : public IDeviceInfo
{
public:
  // Enabled/disabled device settings are per subscriber.
  // If consumer id is unknown, supply 0 - it will be assigned by supplier.
  virtual int consumeDevice(IDeviceConsumer* consumer, int consumerId) = 0;

  virtual void enumDevices(IDeviceConsumer* consumer) = 0;

  // The method returns false if newDevice is disabled, forces enabling newDevice
  // and moves previous device in stack.
  // If previous device was turned off, sends enabled device signal
  // Device selections are per consumer, so, this supply is different for different
  // consumers.
  virtual bool changeDevice(IDeviceConsumer* consumer,
    const IDeviceInfo* newDevice) = 0;

  // The method returns false if no devices, error or 'STACK' policy
  // for auto-changing devices is not used.
  virtual bool enableDevice(IDeviceConsumer* consumer) = 0;
  virtual void disableDevice(IDeviceConsumer* consumer) = 0;
};

class IPersistSettings
{
public:

};

class ISettingsStore
{
public:
  virtual IPersistSettings* settingsFor(const char* componentId) = 0;
};

/*
void foo()
{
  class AudioCaptureSources : public IDeviceSupply
  {
  };

  class SelectMicrophoneGui : public IDeviceConsumer
  {
  };

  SelectMicrophoneGui g;
  AudioCaptureSources s;

  s

  ISettingsStore* store = 0;

  SourceDevices audioSrc(store->settingsFor("audio_src"));
  //DeviceChannel* ch0 = audioSrc.getChannel("ch0");
  DeviceChannel ch1;
  audioSrc.createChannel("ch1");

  IExternalObserver* encodersEngine = 0;

  ch1.setExternalObserver(encodersEngine);
}
*/

/*
Есть платформа. На ней обычно вертится ОС и подключены устройства
ввода-вывода. На ней запускается наша программа и в ней напрямую
доступны кадры памяти потоков данных устройств ввода-вывода.

Каждая платформа при установке нашей программы на ней получает
свой уникальный ID.

На каждой платформе есть подключаемые устройства и встроенные,
грань относительно условная, но нам нужно научиться разделять устройства.

Можно забить на классификацию и трактовать все устройства,
как встроенные. Если устройство внезапно пропадает из списка перечисления
(а не становится недоступным), мы сразу же навсегда классифицируем его как отключаемое. Плюс даём возможность пользователю указывать, что эти устройства не встроенные (ну, и вертать взад - для удобства). Встроенные устройства просто будут фигурировать в списках-выбиралках первыми. Плюс для отключаемых устройств можно будет задавать отдельные правила активации взамен, то есть устройства могут объединяться в группы, но это очень условно.

Главная сущность - совокупность источников и правил переключения с одного на другой в случае недоступности одного. Программа переключений с одного источника на другой. Схема смешения и наложения разных источников, разных спецэффектов. Источниками также могут быть другие такие сущности.

Сущность абстрагируется от устройства. Полностью. Представляется в виде непрерывного потока видео- и аудиоканалов и последовательности переключений между источниками. Для будущего может быть программа как запланированных выборов, так и запрограммированных условий (плюс триггеры разные и т.п).
Опубликовать можно только сущность - то есть каждый поток с микрофона/камеры также является сущностью. Прошлое же всё пишется. Неизменно. При совместном редактировании сущность определяется в будущем, причём, крайне желательно, ненаступившем. Но прямой эфир можно домонтировать прямо в реалтайме - просто суть в том, что при переходе времени в реальное результаты монтажа должны материализовываться (и для этого они должны быть опубликованы).
Неопубликованная сущность может только редактироваться совместно: для реалтаймовых источников нужно их наличие, для исторических - ссылки на диапазоны. Файлы импортируются как исторические сущности. Экспортируются - как dst'ы. Вся эта хрень работает, только если есть dst.

Dst - материализованное представление. Исключительно, иначе запутаемся. Каскадность и программируемость сущностей позволяет собрать любые цепочки потоков.
Управление материализацией осуществляется на уровне сущность -> dst.
Для сущности есть также права доступа. Как на просмотр каналов (можно вешать отдельные права), так и на ретрансляцию - включение данных сущности в содержимое своих публикуемых сущностей. Вместе с правом просмотра может быть отдельное права экспорта в файл.
Итого, права:
- Материализация канала (можно сделать разные права на разное качество)
- Публикация канала - при совместном доступе, активация канала
- Ретрансляция канала (вывод в другую сущность)
- Экспорт канала (сохранение в файл и т.п. ОТТОРЖЕНИЕ из системы)

Уточнение понятия сущности: она есть канал и содержит субканалы.
В рамках канала подканалы могут быть скрытыми или недоступными.
То есть, у каждого субканала должны быть права на их перечисляемость в рамках канала. Это позволит сделать приватные кастомизированные субканалы по пользователям в огромном количестве. При монтаже можно запрограммировать, каким группам пользователей какие блоки будут передаваться. Тут воображение рисует персонализированные рекламные минибаннеры / бегущую строку (можно даже попытаться принимать в таком формате смски и прочую бегущую информацию). Пользователи смогут настраивать свои персонализированные представления для каналов (создавая, таким образом, ретрансляцию канала. Если в канале накладывается картинка-в-картинке, пользователи должны иметь права менять параметры наложения. Например, логотип канала и координаты бегущей строки. Вообще, композицию кадра. И включать свои источники, например персональные смс/почту, другие каналы. Причём включение идёт как по экрану, так и по звуку. Несущий канал может содержать в себе определители ряда устройств, а не только двух (одного экрана и одного динамика) - и пользователь должен иметь возможность перераскидывать такой мультиченнел.

Для удобства просмотра, каналы вещаются в предкомпозиции, но пользователь всегда может перенастроить всё, что захочет. И, да... Если рассматривать пользовательскую перенастройку, то выбор смещения времени для каждого входного канала пользователь имеет право сделать сам - каналы в рамках материализуемого потока не обязаны быть синхронизированными. Материализуемый поток, который пользователь смотрит, становится историческим потоком, и доступен для просмотра другими людьми при условии его публикации или самим пользователем в будущем.

При таком оформлении потоков могут быть виртуальные материализаторы - чтобы позволять публиковать непросматриваемые или просматриваемые в другом разрешении потоки.

Понятие "связи по картине" как раз является публикуемой сущностью канала. Навигация по каналам-источникам, конечно, может быть запрограммированная, или прямая, в том числе рассинхронизированная между разными каналами-источниками.

Опубликованная "связь по картине" имеет точные сопоставления моментов времени с моментами источников. Для любого момента можно назначить права (в том числе, на прошлые - убрать контент из просмотра). Также, для опубликованной "связи по картине" есть прошлое - его изменить нельзя, только задать права. Настоящее можно менять "на лету", будущее - планировать и программировать. Для будущих фрагментов можно утвержать фиксацию (обещание, что не будешь менять), либо прямо говорить, что будет динамический контент.

Все эти няшки позволят обеспечить беспредельную персонализацию контента.

Эти няшки абсолютно виртуальны с точки зрения данных.

Исходные данные записываются, сжимаются, передаются между узлами, ведется учет, на какой узел какой блок данных передан, как долго на него можно ПЫТАТЬСЯ полагаться (кэш в памяти), уведомления о выходе узлов из сети, об очистке блоков из кэшей, уведомлений о персистентности/очистке с диска.

Передача ленивая и строится на программах "связей по картине".

Связь по картине определяет ремаппинг всех входящих каналов на локальное представление. То есть, по сути, позволяет разобрать исходный канал на кусочки и перераспределить эти кусочки по другим субканалам (в том числе в любом порядке времени). Кусочки - видео (в том числе отрендеренный текст) и аудио. Правила определяют принципы наложения. Рендеринг всегда клиент-сайдовый, так что доступны все оригинальные фрагменты (если не ограничить права доступа к высокому качеству). Можно пересобирать контент, смешивая звук, применяя сложные спецэффекты, накладывая изображение. Это выглядит как транскодирование и влечет потерю качества, если первичные источники (несжатые стримы) нелокальные. Рендерингом занимаются специальные плагины. Такие плагины получают каналы на вход (собирая их автоматически, декодируя, если это не реалтаймовые декодированные) и выдают каналы на выход, причём, необязательно в реалтайме - просто при их работе актуализируются результирующие каналы. Выходные каналы рендереров всегда несжатые, и сжимаются при персистенсе и передаче. Эти каналы всегда можно опубликовать, добавив ссылки на них в любую "связь по картине".

Рендерер может быть продакшеновый - его выходы публикуются. Либо драйвероподобный - его выходы отправляются на локальные устройства воспроизведения/отображения.

Сущность можеть иметь групповые права на все каналы плюс спецификации.
Права могут назначаться на диапазоны времени.

Система кеширования, доставки и долговременного хранения:
Подсистема долговременного хранения активируется, когда на поток-источник появляется ссылка в "связи по картине".
Кеширование связано как с доставкой, так и с хранением.
Подсистема доставки балансирует нагрузку на сеть и на память.

Клиент, желая что-нить посмотреть, заявляет "у меня есть устройство вывода такое-то". Указывает права доступа на запись для конкретного канала, и добавляет ограничения - время (в будущем), когда этот доступ будет активен, а также самое главное ограничение - позицию времени, которую вещатель имеет право сюда пушить. Позиция может быть прошлым - система долговременного храниения и кеширования автоматически начнет собирать блоки данных. То есть, доступ на запись в устройство вывода конкретным каналам предоставляется для реалтаймовой трансляции или с небольшой задержкой или для будущих эфиров. Доступ на запись прошлого предоставляется подсистеме кеширования, долговременного хранения и передачи.

То есть, управлять текущей записью в каналы прошлого мы не должны уметь - только переключением реалтайма и планированием будущего. Таким образом, в точках вывода доступна опция обращения к прошлому эфиру, но она инициируется исключительно локальным зрителем на самом высоком уровне абстракции - как конечным пользователем. А реалтаймовый и будущий доступ он должен уметь выдавать каналу.


МОДЕЛЬ УПРАВЛЕНИЯ ПРАВАМИ ПОЛЬЗОВАНИЯ ОБЪЕКТАМИ, КОТОРЫМИ В ЕДИНИЦУ ВРЕМЕНИ
МОЖЕТ ПОЛЬЗОВАТЬСЯ ТОЛЬКО ОДИН СУБЪЕКТ.

Есть камера. Есть микрофон. Есть устройство (телефон, компьютер, ноутбук, нетбук, планшет). Есть экран. Есть динамики. Есть владелец всего этого - человек, который по-умолчанию имеет права пользования. Есть пользователь - человек, который имеет право этим пользоваться. Есть другие люди. Пользователь может делиться всем, что его камера наснимает. Пользователь может выводить любой контент куда захочет на свое устройство.
Пользователь может предоставить общий доступ к своему экрану на запись, и позволить другим выводить на него их контент. Так как такая запись может быть одновременной несколькими чужими пользователями, то пользователь должен уметь резать экран на кусочки и предоставлять чужим доступ только к фрагменту экрана.
Пользователь может в любой момент забрать эти права. Также, как и выключить своё удаленное устройство или потерять с ним связь.
Исходя из возможности предоставления общего доступа, получается, что у пользователя могут быть его устройства, на которые он может выводить и с которых он может писать, и доступом к которым он может управлять и устройства других пользователей, к которым у него может быть частичный доступ - например, только к экрану или даже его части.



У устройства может быть 10 экранов, 100 микрофонов, 50 динамиков и 5 камер. И права использования всех этих прелестей могут быть у разных людей.

Так как камеры и экраны планарны, то кажется оверинжинирингом выдумывать доступ к части экрана или к части камеры. Да, резать можно как хочешь, но доступ должен предоставляться к поверхности целиком, тогда останется конкретика. Другой момент - время. Ты в одно время можешь ходить голый по дому, и не хотел бы, чтобы за тобой подглядывали. В другое время можешь дать доступ к своей камере. Или дочка смотрит мультики на каком-нибудь общем экране. А потом приходят серьёзные дяди и тебе нужно использовать этот экран по-другому. Короче, если шаришь экран, то целиком.

Итого: управление выводом и вводом:
 - локальные устройства ввода-вывода
 - удаленные устройства ввода-вывода на своих устройствах
 - устройства, доступ к которым предоставлен (отзываемый)
 - предоставлен доступ без права предоставления доступа (пользоваться можешь. но только сам)

Что есть управление? Возможность задавать, какие потоки информации с каких устройств на какие должны передаваться. Чтобы это делать, необходимо определить структуру устройств и потоков.

Определим право частной собственности, как священное (даже в условиях РОЭ, где не надо ничего покупать или обмениваться, чтобы получить блага).
Почему? Потому что это право позволяет человеку в любой момент времени точно определить вещи, которыми он имеет право неограниченно пользоваться.
У частной собственности есть бесспорное преимущество гарантированной рефенсности - человек в любой момент знает, что оно у него есть, и может получить к этому доступ. Это даёт возможность гарантированного выполнения операций по манипулированию пространством, без которого человек не может ничего делать - делать могут только с ним.

Затем идёт право пользования чужой вещью - когда другой человек выдаёт тебе что-то в пользование, но право частной собственности оставляет за собой.
Здесь есть 2 варианта передачи:
1. Вещь передаётся с условием обязательного возврата её в любое время по требованию арендодателя.
2. Вещь передаётся с условием, что арендодатель не имеет права забирать её в определённые интервалы времени.
Все остальные варианты являются необязательными, и к требованиям не относятся. Так как даже если передать что-то в аренду на длительное время, а потом оно вдруг понадобилось арендодателю, то возврат будет относиться либо к п.1, либо к п.2.

Сюда также добавляется дополнительное право передачи в субаренду - оно просто может быть или не быть. Если арендодатель не имеет права забирать вещь в произвольные моменты времени, право субаренды на любом условии, хоть по п.1, хоть по п.2 включается автоматически. При возврате в любое время арендодатель может выбирать условия, оставляя право передачи в субаренду, либо не давая его явно.

Хотя с другой стороны, пользователю не всегда нужны обе возможности одновременно - возможности распоряжаться вещью (передавать её в пользование) и возможность пользоваться. Тогда можно субарендуемость включить и во временногарантированную аренду.

Мы говорим про идеальный мир.

Итого с арендой 4 варианта:
1. Возвращаемая несубарендуемая
2. Возвращаемая субарендуемая
3. Блокируемая несубарендуемая
4. Блокируемая субарендуемая

Далее - совместная договорённость о пользовании чем-либо.

Такое возможно только при изначальном отсутсвии права частной собственности
(а такого не может быть) или при добровольном отчуждении
(без гарантии возврата, но с возможностью договорившись со всеми забрать).

Устройством кто-то владеет. Подключаемым устройством - тоже, может быть другой человек. Встроенными устройствами (фронтальной и тыловой камерой, микрофоном, динамиками) - тот же, что и устройством.
Далее, при удаленном доступе управлять положением устройства может другой
человек, чем тот, который им пользуется. Камеру он может направить в другую сторону. Далее, есть экран. Тот, кто владеет экраном, может его выключить.
Если экран виден другим людям, то он после такого виден может перестать быть.
То же с динамиками. Но даже больше - тот, кто владеет помещением может их
выключить, и должен иметь на это полное право.

На эту тему можно даже книгу написать, типа Designing Ideal World.

Видно, что нормальная модель доступа и возможности делиться требует,
чтобы и в реальном мире работали конкретные законы. Требует учитывать это,
как минимум. Или добавлять инструменты гарантий.

Моделируется система, в которой в единицу времени одним объектом
может пользоваться один субъект.

Субъекты могут создавать новые объекты, пользуясь другими объектами,
или копируя имеющиеся, но также пользуясь другими объектами.

Объекты могут собираться из составных объектов, и тогда ими в единицу
времени пользоваться могут разные субъекты. Но это не обязательное
требование - пока совокупностью объектов, составляющей большой составной объект,
может пользоваться в единицу времени только один субъект (но ничуть не больше!
например, дом - вполне себе НЕ объект, которым в единицу времени может
пользоваться ТОЛЬКО один субъект. Покуда в целом доме может поместиться
больше одного субъекта. Но вот маленькая кровать - вполне себе объект,
если рассматривать вид пользования "лежать".
Если рассматривать вид пользования "сидеть", то одна кровать вполне себе делится на составные объекты, и причём эти объекты СОЗДАЮТСЯ и УНИЧТОЖАЮТСЯ прямо
в процессе использования. Так, допустим, кровать крошечная и сидеть на ней могут
только два человека со стандартной шириной попы. У субъектов есть атрибуты,
и в зависимости от этих атрибутов возможности пользования объектами могут
меняться. Это не только ширина попы, но и, например, УМЕНИЕ применять
совокупность объектов ради вида пользования СОЗДАВАТЬ.
Так вот, на крошечной кровати, в момент, когда на неё садится один человек
со "стандартной" попой, на ней создаётся субъобъект, которым в единицу
времени может пользоваться только один человек со "стандартной" попой.
Человек умеет садиться на кровать, благодаря этому он может создавать
такой субъобъект.

Так вот, на ту же кровать рядом может сесть ещё один человек, и они создадут
два субъобъекта - левое и правое места на кровати.

Как только они встанут, места пропадают. Потому что на ту же кровать может
сесть другой человек ПОСЕРЕДИНЕ, и место будет только одно.

ГРАНУЛЯРНОСТЬ ОБЪЕКТА ЗАВИСИТ ОТ ВИДА ПОЛЬЗОВАНИЯ И ОТ АТРИБУТОВ СУБЪЕКТА.

Поэтому объект, вообще говоря, человеческая абстракция, НЕ ИМЕЮЩАЯ НИЧЕГО
ОБЩЕГО С РЕАЛЬНОСТЬЮ. А вот субъекты, на первый взгляд,
вполне себе гранулярны. Хотя могут собираться в стаи и действовать сообща.
Я полагаю, для субъектов скорее всего, та же группировка работает,
но один человек - что то вроде атомарного субъекта - минимальной пользующейся
единицы. Но представим устройства (авианосец?), которыми можно управлять
только сообща, кучей народу. Минимально пользующаяся единица здесь много шире
одного человека. Субъекты состоят из персоналий и могут объединяться для
сложных видов пользования, требующих мультиперсональных субъектов.

Объекты могут делиться произвольно, субъектами в процессе использования крупных
объектов, на малые (деление может быть только на время пользования, как кровать,
или принципиальным, как длинное бревно, которое распилили),
преобразовываться для создания новых объектов или использоваться для создания новых объектов.

Так вот, владение - не есть пользование. Владение бревном, например, это
право его таскать. Потом мы можем его распилить его на пеньки
и сидеть, где захотим (!) только на тех, которые мы можем таскать.

До распила на одном бревне могло сидеть куча народу, но выбирать, ГДЕ,
они могли либо сообща, либо с решением владельца, что, по-сути, одно и то же.

Владение - право передачи объекта и модификации объекта.
Пользование не включает в себя право модификации объекта. Пользователь
не может нарушить идентичность объекта. Если может, то он - владелец.

Но пользователь может трансформировать объект и передать его другому
пользователю. Например, поставить софт на телефон, зацарапать его,
просадить аккумулятор или разбить экран.


Субъектам нужны объекты для жизни (пользования ради потребления)
и для создания новых объектов - для пользования другими людьми
и создания новых объектов.

Нельзя смоделировать систему, в которой есть объекты, 

Отключить использование права пользования нельзя, иначе теряешь
временнЫе гарантии, и не можешь полноценно пользоваться.
Отключить возможность делиться тоже нельзя, потому что всё, что мы можем
сами создать, бессмысленно без предоставления этого другим людям
и без получения созданного ими.

*/